import { Injectable, Logger } from '@nestjs/common';
import { FileVariantType, IngestionJobStatus, IngestionJobType, Prisma } from '@prisma/client';

import { PrismaService } from '@/prisma.service';

@Injectable()
export class IngestionQueueService {
    private readonly logger = new Logger(IngestionQueueService.name);
    private readonly queue: string[] = [];
    private processing = false;

    constructor(private readonly prisma: PrismaService) { }

    async enqueueNormalizeJob(fileId: string) {
        this.queue.push(fileId);
        await this.processQueue();
    }

    private async processQueue() {
        if (this.processing) {
            return;
        }
        this.processing = true;

        while (this.queue.length) {
            const fileId = this.queue.shift();
            if (!fileId) {
                continue;
            }
            await this.handleJob(fileId);
        }

        this.processing = false;
    }

    private async handleJob(fileId: string) {
        const file = await this.prisma.file.findUnique({
            where: { id: fileId },
            include: { variants: true },
        });

        if (!file) {
            return;
        }

        try {
            await this.prisma.$transaction(async (tx) => {
                await this.ensureOriginalVariant(tx, file);
                await this.ensurePlaceholderVariant(tx, file, FileVariantType.NORMALIZED_PDF, 'application/pdf');
                await this.ensurePlaceholderVariant(tx, file, FileVariantType.PLAIN_TEXT, 'text/plain');
                await this.ensurePlaceholderVariant(tx, file, FileVariantType.STRUCTURED_JSON, 'application/json');

                await tx.ingestionJob.updateMany({
                    where: { fileId: file.id, jobType: IngestionJobType.NORMALIZE_FILE },
                    data: {
                        status: IngestionJobStatus.COMPLETED,
                        completedAt: new Date(),
                        attempts: { increment: 1 },
                        lastError: null,
                    },
                });
            });
        } catch (error) {
            this.logger.error(`Failed to stub variants for ${fileId}: ${error.message}`);
            await this.prisma.ingestionJob.updateMany({
                where: { fileId, jobType: IngestionJobType.NORMALIZE_FILE },
                data: {
                    status: IngestionJobStatus.FAILED,
                    attempts: { increment: 1 },
                    lastError: error.message,
                },
            });
        }
    }

    private async ensureOriginalVariant(tx: Prisma.TransactionClient, file: Prisma.FileGetPayload<{ include: { variants: true } }>) {
        await tx.fileVariant.upsert({
            where: {
                fileId_variantType: {
                    fileId: file.id,
                    variantType: FileVariantType.ORIGINAL,
                },
            },
            create: {
                fileId: file.id,
                variantType: FileVariantType.ORIGINAL,
                storageKey: file.storageKey,
                url: `/api/ingestion/files/${file.id}/content`,
                mimeType: file.mimeType,
                size: file.size,
                checksum: file.checksum,
                metadata: { note: 'Uploaded blob' },
            },
            update: {
                storageKey: file.storageKey,
                mimeType: file.mimeType,
                size: file.size,
                checksum: file.checksum,
            },
        });
    }

    private async ensurePlaceholderVariant(
        tx: Prisma.TransactionClient,
        file: Prisma.FileGetPayload<{}>,
        variant: FileVariantType,
        mimeType: string,
    ) {
        await tx.fileVariant.upsert({
            where: {
                fileId_variantType: {
                    fileId: file.id,
                    variantType: variant,
                },
            },
            create: {
                fileId: file.id,
                variantType: variant,
                storageKey: file.storageKey,
                url: `/api/ingestion/files/${file.id}/variants/${variant.toLowerCase()}`,
                mimeType,
                metadata: {
                    status: 'PENDING',
                    note: 'Stub generated by ingestion queue',
                },
            },
            update: {
                metadata: {
                    status: 'PENDING',
                    note: 'Stub refreshed',
                },
            },
        });
    }
}
